#!/usr/bin/env python
import glob
import sys
import argparse
import re
import os


HELP_MESSAGE = """Rename file(s) easily.

EXAMPLES:
Replace characters:
$ _rename -e '-' -f '_' a-long-name.txt
#=> a_long_name.txt

Add leading zeros:
$ _rename -t number -f '%02d' 1.txt
#=> 01.txt

Dry run without affecting your files:
$ _rename -t number -f '%02d' --dry-run 1.txt

Add leading zeros in batch:
$ _rename -t number -f '%02d' *.txt

Change extensions in batch
$ _rename -e 'python' -f 'lua' *.python
"""


parser = argparse.ArgumentParser(
    description=HELP_MESSAGE,
    formatter_class=argparse.RawTextHelpFormatter,
)


parser.add_argument(
    "-t",
    "--type",
    required=False,
    help="Automatically figure what to select (higher priority than --regex)",
)

parser.add_argument(
    "-e",
    "--regex",
    type=str,
    required=False,
    help="Filter patterns using RegEx captured group",
)

parser.add_argument(
    "-f",
    "--format",
    required=True,
    help="Format string following printf-style Python standard",
)

parser.add_argument(
    "-d",
    "--dry-run",
    action="store_true",
    help="""See how command affects your file without executing it""",
)

parser.add_argument("filepaths", nargs="*", type=str, help="File name")

args = parser.parse_args()


SUPPORTED_TYPES = ["number"]


def panic(msg):
    sys.stderr.write("ERROR: {}".format(msg))
    sys.exit(1)


def do_format(m, form, type) -> str:
    """Format captured group following printf-style provided a format string.
    Naively converse captured group's type based on format pattern.
    """
    captured = m.group(0)
    if form[-1] == "d":
        captured = int(captured)
    if "%" in form:
        return form % captured
    return form


def convert(filepath, form, type=None, regex=None, dry_run=False):
    """Do the conversion for one file."""
    if not os.path.isfile(filepath):
        panic("{} not found.".format(filepath))

    if type == "number":
        regex = r"(\d+)"

    components = os.path.split(filepath)
    new_filename = re.sub(regex, lambda m: do_format(m, form, type), components[-1])
    new_filepath = os.path.join(*(components[:-1] + (new_filename,)))

    if dry_run:
        print("{} -> {}".format(filepath, new_filepath))
    else:
        os.rename(filepath, new_filepath)


if __name__ == "__main__":
    type = None
    if args.type:
        type = args.type.lower()
        if type not in SUPPORTED_TYPES:
            panic("{} is not supported".format(type))

    if not args.type and not args.regex:
        panic("At least --type or --regex must be provided.")

    if not args.filepaths:
        parser.print_help()
        sys.exit(1)

    if args.dry_run:
        print("DRY RUN:")

    for filepath in args.filepaths:
        convert(filepath, args.format, type, args.regex, args.dry_run)
