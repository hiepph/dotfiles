#!/usr/bin/env python
import sys
import argparse
import re
import os

parser = argparse.ArgumentParser(
    description="""Rename file(s) easily.

EXAMPLES:
Replace characters:
$ _rename -e '-' -f '_' a-long-name.txt
#=> a_long_name.txt

Add leading zeros:
$ _rename -t number -f '%02d' 1.txt
#=> 01.txt

Dry run without affecting your files:
$ _rename -t number -f '%02d' 1.txt --dry-run

Add leading zeros in batch:
$ ls *.txt | _rename -t number -f '%02d'

Change extensions in batch
$ ls *.python | _rename -e 'python' -f 'lua'
""",
    formatter_class=argparse.RawTextHelpFormatter,
)


parser.add_argument(
    "-t",
    "--type",
    required=False,
    help="Automatically figure what to select (higher priority than --regex)",
)

parser.add_argument(
    "-e",
    "--regex",
    type=str,
    required=False,
    help="Filter patterns using RegEx captured group",
)

parser.add_argument(
    "-f",
    "--format",
    required=True,
    help="Format string following printf-style Python standard",
)

parser.add_argument(
    "-d",
    "--dry-run",
    action="store_true",
    help="""See how command affects your file without executing it""",
)

parser.add_argument("filepath", nargs="?", type=str, help="File name")

args = parser.parse_args()


SUPPORTED_TYPES = ["number"]


def panic(msg):
    sys.stderr.write("ERROR: {}".format(msg))
    sys.exit(1)


def do_format(m, form, type) -> str:
    """Format captured group following printf-style provided a format string.
    Naively converse captured group's type based on format pattern.
    """
    captured = m.group(0)
    if form[-1] == "d":
        captured = int(captured)
    if "%" in form:
        return form % captured
    return form


def convert(filepath, form, type=None, regex=None, dry_run=False):
    """Do the conversion for one file."""
    if not os.path.isfile(filepath):
        panic("{} not found.".format(filepath))

    if type == "number":
        regex = r"(\d+)"

    components = os.path.split(filepath)
    new_filename = re.sub(regex, lambda m: do_format(m, form, type), components[-1])
    new_filepath = os.path.join(*(components[:-1] + (new_filename,)))

    if dry_run:
        print("{} -> {}".format(filepath, new_filepath))
    else:
        os.rename(filepath, new_filepath)


type = None
if args.type:
    type = args.type.lower()
    if type not in SUPPORTED_TYPES:
        panic("{} is not supported".format(type))

if not args.type and not args.regex:
    panic("At least --type or --regex must be provided.")

if args.dry_run:
    print("DRY RUN:")

if args.filepath:
    convert(args.filepath, args.format, type, args.regex, args.dry_run)
else:
    for filepath in sys.stdin:
        convert(filepath.strip(), args.format, type, args.regex, args.dry_run)
